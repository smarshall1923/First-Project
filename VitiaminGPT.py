# Import the required libraries

from dotenv import load_dotenv
load_dotenv()
import os
import openai
import requests
import streamlit as st
import streamlit_shadcn_ui as ui
import pandas as pd

# Set the OpenAI API key
openai.api_key = "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"
NOTION_TOKEN = "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"
DATABASE_ID = "5d35421663fe448a87dc15cfd30a6c9b"
#DATABASE_ID = os.getenv("DATABASE_ID")


# Call OpenAI API
def CallChatCompletion(Question: str):
    chat_completion = openai.ChatCompletion.create(
        messages=[
            {
                "role": "user",
                "content": Question,
            }
        ],
        model="gpt-4o",
    )
    # Extract the content from the response
    return chat_completion.choices[0].message['content']


# Create a simple Streamlit app
placeholder = st.empty()
placeholder.title("Steve's Vitamin List From Notion")
placeholder.write("This is a list of vitamins from a Notion database. Each vitamin has a one line overview generated by ChatGPT.")



# Function to create an xpandable section and show a message inside it
def PushToCard(answer: str, vitamin: str, unique_id: int):
    # Use st.markdown to inject custom CSS for the card
    st.markdown(
        """
        <style>
        .custom-card {
            width: 500px;  /* Adjust the width as needed */
            height: 300px; /* Adjust the height as needed */
            padding: 20px; /* Optional: Add padding for better spacing */
            border: 1px solid #ccc; /* Optional: Add a border */
            border-radius: 10px; /* Optional: Add rounded corners */
            box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.1); /* Optional: Add a shadow */
        }
        </style>
        """,
        unsafe_allow_html=True
    )
    
    # Apply the custom CSS class to the card
    with ui.card(content=answer, key=f"{vitamin}-{unique_id}"):
        ui.card.__init__(vitamin)
        ui.textarea(answer)
        ui.button("More Info On " + vitamin)

# Function to push the answer and vitamin to the table
def PushToTable(answer: str, vitamin: str):
    # Append new row to the table data
    st.session_state.table_data.append({"Vitamin": vitamin, "Answer": answer})

# Function to create an expandable section and show a message inside it
def PushToExpander(answer: str, vitamin: str, col):
    with col.expander(f"More Info On {vitamin}"):
        st.write(answer)
    
# Initialize session state for table data
if 'table_data' not in st.session_state:
    st.session_state.table_data = []





# Notion Integration Setup
headers = {
    "Authorization": "Bearer " + NOTION_TOKEN,
    "Content-Type": "application/json",
    "Notion-Version": "2022-06-28",
}

#Read thru the Notion Pages
def get_pages(num_pages=None):
    
    #If num_pages is None, get all pages, otherwise just the defined number.
    
    url = f"https://api.notion.com/v1/databases/{DATABASE_ID}/query"
    new_var = num_pages is None
    get_all = new_var
    page_size = 100 if get_all else num_pages
    payload = {"page_size": page_size}
    response = requests.post(url, json=payload, headers=headers)
    data = response.json()
    if 'results' not in data:
        raise KeyError("'results' key not found in the response data")
    results = data["results"]
    while data.get("has_more") and get_all:
        payload = {"page_size": page_size, "start_cursor": data["next_cursor"]}
        response = requests.post(url, json=payload, headers=headers)
        data = response.json()
        results.extend(data["results"])
    return results
columns = st.columns(3)  # Create three columns



# Get the information from the Notion database
pages = get_pages()
for i, page in enumerate(pages):
    # Look through the dictionary
    # Check if the "Title" property exists and print its structure
    if "Title" in page["properties"]:
        if page["properties"]["Title"]:
            title_property = page["properties"]["Title"]
            if isinstance(title_property, dict):
                if "title" in title_property and "content" in title_property["title"][0]["text"]:
                    vitamin = title_property["title"][0]["text"]["content"]
                    # Get a one line overview from ChatGPT for each vitamin found
                    question = f"Give me a one line overview of the supplement called {vitamin}"
                    # Push the result to the table
                    answer = CallChatCompletion(question)
                    #PushToTable(answer, vitamin)
                    #PushToCard(answer, vitamin, i)
                    col = columns[i % 3]  # Cycle through the columns
                    PushToExpander(answer, vitamin, col)


 # Convert the table data to a DataFrame
df = pd.DataFrame(st.session_state.table_data)


# Optionally, you can use CSS to style the table
st.markdown(
    """
    <style>
    .dataframe th, .dataframe td {
        padding: 10px;
        text-align: left;
    }
    .dataframe td:nth-child(1) {
    font-weight: bold;
    </style>
    """,
    unsafe_allow_html=True
)


 # Use st.dataframe to display the updated table
st.dataframe(df, width=1500, height=400)

